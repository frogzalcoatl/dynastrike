<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Dynastrike Demo</title>
	<style>
		body {
			width: 100%;
			height: 100%;
			border: 0;
			margin: 0;
			padding: 0;
			display: flex;
			justify-content: center;
			align-items: center;
			background-color: #202020;
		}
	</style>
</head>

<body>
	<script src="../dist/dynastrike.global.js"></script>
	<script>
		const scene = new Dynastrike.Scene({
			minX: -16384,
			minY: -16384,
			maxX: 16384,
			maxY: 16384
		}, 16);
		const random = (function* seededRandom(seed) {
			let t = seed;
			while (true) {
				t += 0x6D2B79F5;
				let r = Math.imul(t ^ t >>> 15, t | 1);
				r ^= r + Math.imul(r ^ r >>> 7, r | 61);
				yield ((r ^ r >>> 14) >>> 0) / 4294967296;
			}
		})(1);
		const generators = [
			() => null,
			() => Dynastrike.generatePolygon(0, 0, 1, 3 + Math.floor(4 * random.next().value)),
			//() => Dynastrike.generateStar(0, 0, 1, 1, 0.5, 3 + Math.floor(4 * random.next().value)),
			//() => Dynastrike.generateHeart(0, 0, 1, 10 + 10 * Math.floor(4 * random.next().value))
		]
		for (let i = 0; i < 4096; i++) {
			const x = scene.box.minX + random.next().value * (scene.box.maxX - scene.box.minX);
			const y = scene.box.minY + random.next().value * (scene.box.maxY - scene.box.minY);
			const radius = 20 + 50 * random.next().value;
			const entity = new Dynastrike.Entity(x, y, radius, generators[Math.floor(generators.length * random.next().value * random.next().value)]());
			scene.addEntity(entity);
			entity.angle = Math.PI * 2 * random.next().value;
		}
		let playerEntity = new Dynastrike.Entity(-12.5, 0, 5000, [-30, -1, 30, -1, 30, 1, -30, 1]);
		playerEntity.mass = 1000;
		scene.addEntity(playerEntity);
		for (let i = 0; i < generators.length * 4; i++) {
			const x = scene.box.minX + random.next().value * (scene.box.maxX - scene.box.minX);
			const y = scene.box.minY + random.next().value * (scene.box.maxY - scene.box.minY);
			const radius = (20 + 50 * random.next().value) * 25;
			const entity = new Dynastrike.Entity(x, y, radius, generators[i % generators.length]());
			entity.mass = 500;
			scene.addEntity(entity);
		}
		const canvasElement = document.createElement("canvas");
		document.body.appendChild(canvasElement);
		const ctx = canvasElement.getContext("2d", { alpha: false, willReadFrequently: false, desynchronized: true });
		function resizeEvent() {
			canvasElement.width = window.innerWidth;
			canvasElement.height = window.innerHeight;
			ctx.imageSmoothingEnabled = true;
		}
		window.addEventListener("resize", () => resizeEvent());
		resizeEvent();
		let commands = 0;
		addEventListener("keydown", function (event) {
			switch (event.code) {
				case "KeyW": commands |= 1; break;
				case "KeyS": commands |= 2; break;
				case "KeyA": commands |= 4; break;
				case "KeyD": commands |= 8; break;
				case "KeyK": commands ^= 16; break;
			}
		});
		addEventListener("keyup", function (event) {
			switch (event.code) {
				case "KeyW": commands &= ~1; break;
				case "KeyS": commands &= ~2; break;
				case "KeyA": commands &= ~4; break;
				case "KeyD": commands &= ~8; break;
			}
		});
		function playerInput() {
			if (commands & 1) {
				playerEntity.velocityY -= 2;
			}
			if (commands & 2) {
				playerEntity.velocityY += 2;
			}
			if (commands & 4) {
				playerEntity.velocityX -= 2;
			}
			if (commands & 8) {
				playerEntity.velocityX += 2;
			}
			if (commands & 16) {
				playerEntity.angularVelocity += 0.0025;
			}
		}
		let cameraX = 0;
		let cameraY = 0;
		let cameraRenderRatio = 0;
		let cameraRatio = 0;
		let draggingEntity = null;
		let dragOffset = { x: 0, y: 0 };
		canvasElement.oncontextmenu = () => false;
		canvasElement.addEventListener("wheel", function (event) {
			cameraRatio = Math.max(-2, Math.min(6, cameraRatio + (event.deltaY > 0 ? 0.2 : -0.2)));
			event.preventDefault();
		});
		canvasElement.addEventListener("mousedown", function (event) {
			const boundingRectangle = canvasElement.getBoundingClientRect();
			const mouseX = event.clientX - boundingRectangle.left;
			const mouseY = event.clientY - boundingRectangle.top;
			const zoomFactor = Math.pow(2, cameraRenderRatio);
			const worldX = (mouseX - canvasElement.width / 2) * zoomFactor + cameraX;
			const worldY = (mouseY - canvasElement.height / 2) * zoomFactor + cameraY;
			const candidates = scene.query({ minX: worldX, minY: worldY, maxX: worldX, maxY: worldY });
			let closestEntity = null;
			let closestDistance = Infinity;
			for (const entity of candidates) {
				const distanceX = worldX - entity.positionX;
				const distanceY = worldY - entity.positionY;
				const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
				if (distance <= entity.radius && distance < closestDistance) {
					closestEntity = entity;
					closestDistance = distance;
					dragOffset.x = distanceX;
					dragOffset.y = distanceY;
				}
			}
			if (closestEntity) {
				if (event.button === 0) {
					draggingEntity = closestEntity;
				} else {
					playerEntity = closestEntity;
				}
			}
		});
		canvasElement.addEventListener("mousemove", function (event) {
			if (draggingEntity !== null) {
				const boundingRectangle = canvasElement.getBoundingClientRect();
				const mouseX = event.clientX - boundingRectangle.left;
				const mouseY = event.clientY - boundingRectangle.top;
				const zoomFactor = Math.pow(2, cameraRenderRatio);
				const worldX = (mouseX - canvasElement.width / 2) * zoomFactor + cameraX;
				const worldY = (mouseY - canvasElement.height / 2) * zoomFactor + cameraY;
				draggingEntity.moveBy((worldX - dragOffset.x) - draggingEntity.positionX, (worldY - dragOffset.y) - draggingEntity.positionY);
				draggingEntity.clearForces();
			}
		});
		canvasElement.addEventListener("mouseup", function () {
			draggingEntity = null;
		});
		canvasElement.addEventListener("mouseleave", function () {
			draggingEntity = null;
		});
		const mixColorCache = new Map();
		function hexToRgb(hex) {
			let n = parseInt(hex.slice(1), 16);
			return [(n >> 16) & 0xFF, (n >> 8) & 0xFF, n & 0xFF];
		}
		function mixColor(hex1, hex2, mix) {
			const key = `${hex1}${hex2}${mix.toFixed(2)}`;
			if (mixColorCache.has(key)) {
				return mixColorCache.get(key);
			}
			const rgb1 = hexToRgb(hex1);
			const rgb2 = hexToRgb(hex2);
			const red = (rgb1[0] + ((rgb2[0] - rgb1[0]) * mix)) | 0;
			const green = (rgb1[1] + ((rgb2[1] - rgb1[1]) * mix)) | 0;
			const blue = (rgb1[2] + ((rgb2[2] - rgb1[2]) * mix)) | 0;
			const result = `#${((1 << 24) | (red << 16) | (green << 8) | blue).toString(16).slice(1)}`;
			mixColorCache.set(key, result);
			return result;
		}
		const gridOffscreenCanvas = new OffscreenCanvas(1024, 1024);
		const gctx = gridOffscreenCanvas.getContext("2d");
		gctx.clearRect(0, 0, gridOffscreenCanvas.width, gridOffscreenCanvas.height);
		gctx.strokeStyle = "#405010";
		gctx.lineWidth = 1;
		for (let x = 0; x <= gridOffscreenCanvas.width; x += 32) {
			gctx.beginPath();
			gctx.moveTo(x, 0);
			gctx.lineTo(x, gridOffscreenCanvas.height);
			gctx.stroke();
		}
		for (let y = 0; y <= gridOffscreenCanvas.height; y += 32) {
			gctx.beginPath();
			gctx.moveTo(0, y);
			gctx.lineTo(gridOffscreenCanvas.width, y);
			gctx.stroke();
		}
		function drawBackground() {
			const zoomFactor = Math.pow(2, cameraRenderRatio);
			const viewMinX = cameraX - (canvasElement.width / 2) * zoomFactor;
			const viewMinY = cameraY - (canvasElement.height / 2) * zoomFactor;
			const viewMaxX = cameraX + (canvasElement.width / 2) * zoomFactor;
			const viewMaxY = cameraY + (canvasElement.height / 2) * zoomFactor;
			const backgroundMinX = Math.max(scene.box.minX, viewMinX);
			const backgroundMinY = Math.max(scene.box.minY, viewMinY);
			const backgroundMaxX = Math.min(scene.box.maxX, viewMaxX);
			const backgroundMaxY = Math.min(scene.box.maxY, viewMaxY);
			ctx.fillStyle = "#708040";
			ctx.fillRect(backgroundMinX, backgroundMinY, backgroundMaxX - backgroundMinX, backgroundMaxY - backgroundMinY);
			const pattern = ctx.createPattern(gridOffscreenCanvas, "repeat");
			ctx.fillStyle = pattern;
			ctx.fillRect(backgroundMinX, backgroundMinY, backgroundMaxX - backgroundMinX, backgroundMaxY - backgroundMinY);
		}
		const colors = ["#AAAA00", "#202020", "#7fa97a", "#e09e3e", "#e06666", "#b06b8e", "#7a66b3", "#bfa13a", "#66a3a3", "#a184c6"];
		function drawEntities() {
			const zoomFactor = Math.pow(2, cameraRenderRatio);
			const viewEntities = scene.query({
				minX: cameraX - (canvasElement.width / 2) * zoomFactor,
				minY: cameraY - (canvasElement.height / 2) * zoomFactor,
				maxX: cameraX + (canvasElement.width / 2) * zoomFactor,
				maxY: cameraY + (canvasElement.height / 2) * zoomFactor
			});
			for (const entity of viewEntities) {
				const color = colors[entity.index % colors.length];
				ctx.fillStyle = color;
				//ctx.strokeStyle = mixColor(color, "#000000", 0.35);
				ctx.beginPath();
				if (entity.points === null) {
					ctx.arc(entity.positionX, entity.positionY, entity.radius, 0, Math.PI * 2);
				} else {
					ctx.moveTo(entity.points[0], entity.points[1]);
					for (let i = 2; i < entity.points.length; i += 2) {
						ctx.lineTo(entity.points[i], entity.points[i + 1]);
					}
				}
				ctx.closePath();
				ctx.fill();
				if (cameraRatio < 3) {
					ctx.strokeStyle = "#000000";
					ctx.lineWidth = 0;
					ctx.beginPath();
					ctx.moveTo(entity.positionX, entity.positionY);
					ctx.lineTo(entity.positionX + Math.cos(entity.angle) * entity.radius, entity.positionY + Math.sin(entity.angle) * entity.radius);
					ctx.closePath();
					ctx.stroke();
				}
			}
		}
		function animationFrame() {
			playerInput();
			let sceneUpdateTime = performance.now();
			const measurements = scene.update();
			sceneUpdateTime = performance.now() - sceneUpdateTime;
			let renderTime = performance.now();
			cameraX = cameraX + (playerEntity.positionX - cameraX) * 0.05;
			cameraY = cameraY + (playerEntity.positionY - cameraY) * 0.05;
			cameraRenderRatio = cameraRenderRatio + (cameraRatio - cameraRenderRatio) * 0.1;
			ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
			ctx.fillStyle = "#405010";
			ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
			ctx.save();
			const zoomFactor = Math.pow(2, cameraRenderRatio);
			ctx.setTransform(1 / zoomFactor, 0, 0, 1 / zoomFactor, canvasElement.width / 2 - cameraX / zoomFactor, canvasElement.height / 2 - cameraY / zoomFactor);
			drawBackground();
			drawEntities();
			ctx.restore();
			renderTime = performance.now() - renderTime;
			ctx.fillStyle = "#ffffff";
			ctx.font = "16px monospace";
			ctx.textAlign = "left";
			let y = 0;
			ctx.fillText(`scene update: ${sceneUpdateTime.toFixed(1)}mspt`, 10, y += 20);
			ctx.fillText(`render: ${renderTime.toFixed(1)}mspt`, 10, y += 20);
			requestAnimationFrame(animationFrame);
		}
		requestAnimationFrame(animationFrame);
	</script>
</body>

</html>